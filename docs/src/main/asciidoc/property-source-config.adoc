== Kubernetes PropertySource implementations

配置Spring Boot应用程序的最常用方法是创建`application.properties`或`applicaiton.yaml`或
一个`application-profile.properties`或`application-profile.yaml`文件，包含为您提供自定义值的键值对
应用程序或Spring Boot启动程序。您可以通过指定系统属性或环境来覆盖这些属性
变量。

[[configmap-propertysource]]
=== Using a `ConfigMap` `PropertySource`

Kubernetes提供了一个名为https://kubernetes.io/docs/user-guide/configmap/ [`ConfigMap`]的资源来外化
以键值对或嵌入的`application.properties`或`application.yaml`文件的形式传递给应用程序的参数。
链接：./ spring-cloud-kubernetes-config [Spring Cloud Kubernetes Config]项目使Kubernetes`ConfigMap`实例可用
在应用程序引导期间，当检测到更改时触发Bean或Spring上下文的热重新加载
观察到`ConfigMap`实例。

默认行为是创建一个基于Kubernetes`ConfigMap`的`ConfigMapPropertySource`，其中`metadata.name`值的名称为
您的Spring应用程序（由其`spring.application.name`属性定义）或在其中定义的自定义名称
`bootstrap.properties`文件位于以下键下：`spring.cloud.kubernetes.config.name`。

但是，可以使用多个`ConfigMap`实例进行更高级的配置。
`spring.cloud.kubernetes.config.sources`列表使这成为可能。
例如，您可以定义以下`ConfigMap`实例：

====
[source,yaml]
----
spring:
  application:
    name: cloud-k8s-app
  cloud:
    kubernetes:
      config:
        name: default-name
        namespace: default-namespace
        sources:
         # Spring Cloud Kubernetes looks up a ConfigMap named c1 in namespace default-namespace
         - name: c1
         # Spring Cloud Kubernetes looks up a ConfigMap named default-name in whatever namespace n2
         - namespace: n2
         # Spring Cloud Kubernetes looks up a ConfigMap named c3 in namespace n3
         - namespace: n3
           name: c3
----
====

在前面的示例中，如果尚未设置`spring.cloud.kubernetes.config.namespace`，
名为`c1`的`ConfigMap`将在应用程序运行的命名空间中查找。

找到的任何匹配的`ConfigMap`按如下方式处理：

*应用单个配置属性。
*作为`yaml`应用名为`application.yaml`的任何属性的内容。
*作为属性文件应用名为`application.properties`的任何属性的内容。

上述流程的唯一例外是`ConfigMap`包含指示的* single *键
该文件是YAML或属性文件。在这种情况下，密钥的名称不必是`application.yaml`或
`application.properties`（它可以是任何东西）并且正确处理属性的值。
此功能有助于使用以下内容创建`ConfigMap`的用例：
====
[source]
----
kubectl create configmap game-config --from-file=/path/to/app-config.yaml
----
====

假设我们有一个名为`demo`的Spring Boot应用程序，它使用以下属性来读取其线程池
组态。

* `pool.size.core`
* `pool.size.maximum`

这可以外部化为以“yaml”格式配置映射，如下所示：
====
[source,yaml]
----
kind: ConfigMap
apiVersion: v1
metadata:
  name: demo
data:
  pool.size.core: 1
  pool.size.max: 16
----
====

个别财产在大多数情但是，有时，嵌入式`yaml`更方便。在这种情况下，我们
使用名为`application.yaml`的单个属性来嵌入我们的`yaml`，如下所示：

====
[source,yaml]
----
kind: ConfigMap
apiVersion: v1
metadata:
  name: demo
data:
  application.yaml: |-
    pool:
      size:
        core: 1
        max:16
----
====

以下示例也有效：
====
[source,yaml]
----
kind: ConfigMap
apiVersion: v1
metadata:
  name: demo
data:
  custom-name.yaml: |-
    pool:
      size:
        core: 1
        max:16
----
====

您还可以根据合并在一起的活动配置文件以不同方式配置Spring Boot应用程序
当读取`ConfigMap`时。您可以使用a为不同的配置文件提供不同的属性值
`application.properties`或`application.yaml`属性，指定特定于配置文件的值，每个值都在自己的文档中
（由`---`序列表示），如下：
====
[source,yaml]
----
kind: ConfigMap
apiVersion: v1
metadata:
  name: demo
data:
  application.yml: |-
    greeting:
      message: Say Hello to the World
    farewell:
      message: Say Goodbye
    ---
    spring:
      profiles: development
    greeting:
      message: Say Hello to the Developers
    farewell:
      message: Say Goodbye to the Developers
    ---
    spring:
      profiles: production
    greeting:
      message: Say Hello to the Ops
----
====

在前面的例子中，使用`development`配置文件加载到Spring应用程序中的配置如下：
====
[source,yaml]
----
  greeting:
    message: Say Hello to the Developers
  farewell:
    message: Say Goodbye to the Developers
----
====

但是，如果`production`配置文件处于活动状态，则配置将变为：
====
[source,yaml]
----
  greeting:
    message: Say Hello to the Ops
  farewell:
    message: Say Goodbye
----
====

如果两个配置文件都处于活动状态，则“ConfigMap”中最后显示的属性将覆盖任何先前的值。

要告诉Spring Boot哪个`profile`应该在bootstrap中启用，你可以将系统属性传递给Java
命令。为此，您可以使用可以使用OpenShift定义的环境变量启动Spring Boot应用程序
`DeploymentConfig`或Kubernetes`ReplicationConfig`资源文件，如下：
====
[source,yaml]
----
apiVersion: v1
kind: DeploymentConfig
spec:
  replicas: 1
  ...
    spec:
      containers:
      - env:
        - name: JAVA_APP_DIR
          value: /deployments
        - name: JAVA_OPTIONS
          value: -Dspring.profiles.active=developer
----
====

注意：您应该检查安全配置部分。要从pod内部访问配置映射，您需要具有正确的配置映射
Kubernetes服务帐户，角色和角色绑定。

使用`ConfigMap`实例的另一个选择是通过运行Spring Cloud Kubernetes应用程序将它们安装到Pod中
并让Spring Cloud Kubernetes从文件系统中读取它们。
此行为由`spring.cloud.kubernetes.config.paths`属性控制。你可以使用它
添加或替代前面描述的机制。
您可以使用`，`分隔符在`spring.cloud.kubernetes.config.paths`中指定多个（确切的）文件路径。

注意：您必须提供每个属性文件的完整确切路径，因为目录不是递归解析的。

.Properties:
[options="header,footer"]
|===
| Name                                       | Type      | Default                      | Description
| `spring.cloud.kubernetes.config.enabled`   | `Boolean` | `true`                       | Enable Secrets `PropertySource`
| `spring.cloud.kubernetes.config.name`      | `String`  | `${spring.application.name}` | Sets the name of `ConfigMap` to look up
| `spring.cloud.kubernetes.config.namespace` | `String`  | Client namespace             | Sets the Kubernetes namespace where to lookup
| `spring.cloud.kubernetes.config.paths`     | `List`    | `null`                       | Sets the paths where `ConfigMap` instances are mounted
| `spring.cloud.kubernetes.config.enableApi` | `Boolean` | `true`                       | Enable or disable consuming `ConfigMap` instances through APIs
|===

=== Secrets PropertySource

Kubernetes有https://kubernetes.io/docs/concepts/configuration/secret/[Secrets]的概念用于存储
敏感数据，如密码，OAuth令牌等。这个项目提供与“秘密”的集成来制造秘密
可由Spring Boot应用程序访问。您可以通过设置`spring.cloud.kubernetes.secrets.enabled`属性来显式启用或禁用此功能。

启用后，`SecretsPropertySource`从以下来源查找Kubernetes的`Secrets`：
。从秘密安装中递归读取
。在应用程序之后命名（由`spring.application.name`定义）
。匹配一些标签

Note that, by default, consuming Secrets through the API (points 2 and 3 above) *is not enabled* for security reasons.
Further, we recommend that containers share secrets through mounted volumes.
If you enable consuming Secrets through the API, we recommend that you limit access to Secrets by using an
[authorization policy, such as RBAC](https://kubernetes.io/docs/concepts/configuration/secret/#best-practices).

If the secrets are found, their data is made available to the application.

Assume that we have a spring boot application named `demo` that uses properties to read its database
configuration. We can create a Kubernetes secret by using the following command:

====
[source]
----
oc create secret generic db-secret --from-literal=username=user --from-literal=password=p455w0rd
----
====

The preceding command would create the following secret (which you can see by using `oc get secrets db-secret -o yaml`):

====
[source,yaml]
----
apiVersion: v1
data:
  password: cDQ1NXcwcmQ=
  username: dXNlcg==
kind: Secret
metadata:
  creationTimestamp: 2017-07-04T09:15:57Z
  name: db-secret
  namespace: default
  resourceVersion: "357496"
  selfLink: /api/v1/namespaces/default/secrets/db-secret
  uid: 63c89263-6099-11e7-b3da-76d6186905a8
type: Opaque
----
====

Note that the data contains Base64-encoded versions of the literal provided by the `create` command.

Your application can then use this secret -- for example, by exporting the secret's value as environment variables:

====
[source,yaml]
----
apiVersion: v1
kind: Deployment
metadata:
  name: ${project.artifactId}
spec:
   template:
     spec:
       containers:
         - env:
            - name: DB_USERNAME
              valueFrom:
                 secretKeyRef:
                   name: db-secret
                   key: username
            - name: DB_PASSWORD
              valueFrom:
                 secretKeyRef:
                   name: db-secret
                   key: password
----
====

You can select the Secrets to consume in a number of ways:

. By listing the directories where secrets are mapped:
+
====
[source,bash]
----
-Dspring.cloud.kubernetes.secrets.paths=/etc/secrets/db-secret,etc/secrets/postgresql
----
====
+
If you have all the secrets mapped to a common root, you can set them like:
+
====
[source,bash]
----
-Dspring.cloud.kubernetes.secrets.paths=/etc/secrets
----
====

. By setting a named secret:
+
====
[source,bash]
----
-Dspring.cloud.kubernetes.secrets.name=db-secret
----
====

. By defining a list of labels:
+
====
[source,bash]
----
-Dspring.cloud.kubernetes.secrets.labels.broker=activemq
-Dspring.cloud.kubernetes.secrets.labels.db=postgresql
----
====

.Properties:
[options="header,footer"]
|===
| Name                                        | Type      | Default                      | Description
| `spring.cloud.kubernetes.secrets.enabled`   | `Boolean` | `true`                       | Enable Secrets `PropertySource`
| `spring.cloud.kubernetes.secrets.name`      | `String`  | `${spring.application.name}` | Sets the name of the secret to look up
| `spring.cloud.kubernetes.secrets.namespace` | `String`  | Client namespace             | Sets the Kubernetes namespace where to look up
| `spring.cloud.kubernetes.secrets.labels`    | `Map`     | `null`                       | Sets the labels used to lookup secrets
| `spring.cloud.kubernetes.secrets.paths`     | `List`    | `null`                       | Sets the paths where secrets are mounted (example 1)
| `spring.cloud.kubernetes.secrets.enableApi` | `Boolean` | `false`                      | Enables or disables consuming secrets through APIs (examples 2 and 3)
|===

Notes:
* The `spring.cloud.kubernetes.secrets.labels` property behaves as defined by
https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-Configuration-Binding#map-based-binding[Map-based binding].
* The `spring.cloud.kubernetes.secrets.paths` property behaves as defined by
https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-Configuration-Binding#collection-based-binding[Collection-based binding].
* Access to secrets through the API may be restricted for security reasons. The preferred way is to mount secrets to the Pod.

You can find an example of an application that uses secrets (though it has not been updated to use the new `spring-cloud-kubernetes` project) at
https://github.com/fabric8-quickstarts/spring-boot-camel-config[spring-boot-camel-config]

=== `PropertySource` Reload

Some applications may need to detect changes on external property sources and update their internal status to reflect the new configuration.
The reload feature of Spring Cloud Kubernetes is able to trigger an application reload when a related `ConfigMap` or
`Secret` changes.

By default, this feature is disabled. You can enable it by using the `spring.cloud.kubernetes.reload.enabled=true` configuration property (for example, in the `application.properties` file).

The following levels of reload are supported (by setting the `spring.cloud.kubernetes.reload.strategy` property):
* `refresh` (default): Only configuration beans annotated with `@ConfigurationProperties` or `@RefreshScope` are reloaded.
This reload level leverages the refresh feature of Spring Cloud Context.
* `restart_context`: the whole Spring `ApplicationContext` is gracefully restarted. Beans are recreated with the new configuration.
* `shutdown`: the Spring `ApplicationContext` is shut down to activate a restart of the container.
 When you use this level, make sure that the lifecycle of all non-daemon threads is bound to the `ApplicationContext`
and that a replication controller or replica set is configured to restart the pod.

Assuming that the reload feature is enabled with default settings (`refresh` mode), the following bean is refreshed when the config map changes:

====
[java, source]
----
@Configuration
@ConfigurationProperties(prefix = "bean")
public class MyConfig {

    private String message = "a message that can be changed live";

    // getter and setters

}
----
====

To see that changes effectively happen, you can create another bean that prints the message periodically, as follows

====
[source,java]
----
@Component
public class MyBean {

    @Autowired
    private MyConfig config;

    @Scheduled(fixedDelay = 5000)
    public void hello() {
        System.out.println("The message is: " + config.getMessage());
    }
}
----
====

You can change the message printed by the application by using a `ConfigMap`, as follows:

====
[source,yaml]
----
apiVersion: v1
kind: ConfigMap
metadata:
  name: reload-example
data:
  application.properties: |-
    bean.message=Hello World!
----
====

Any change to the property named `bean.message` in the `ConfigMap` associated with the pod is reflected in the
output. More generally speaking, changes associated to properties prefixed with the value defined by the `prefix`
field of the `@ConfigurationProperties` annotation are detected and reflected in the application.
<<configmap-propertysource,Associating a `ConfigMap` with a pod>> is explained earlier in this chapter.

The full example is available in https://github.com/fabric8io/spring-cloud-kubernetes/tree/master/spring-cloud-kubernetes-examples/kubernetes-reload-example[`spring-cloud-kubernetes-reload-example`].

The reload feature supports two operating modes:
* Event (default): Watches for changes in config maps or secrets by using the Kubernetes API (web socket).
Any event produces a re-check on the configuration and, in case of changes, a reload.
The `view` role on the service account is required in order to listen for config map changes. A higher level role (such as `edit`) is required for secrets
(by default, secrets are not monitored).
* Polling: Periodically re-creates the configuration from config maps and secrets to see if it has changed.
You can configure the polling period by using the `spring.cloud.kubernetes.reload.period` property and defaults to 15 seconds.
It requires the same role as the monitored property source.
This means, for example, that using polling on file-mounted secret sources does not require particular privileges.

.Properties:
[options="header,footer"]
|===
| Name                                                     | Type      | Default                      | Description
| `spring.cloud.kubernetes.reload.enabled`                 | `Boolean` | `false`                      | Enables monitoring of property sources and configuration reload
| `spring.cloud.kubernetes.reload.monitoring-config-maps`  | `Boolean` | `true`                       | Allow monitoring changes in config maps
| `spring.cloud.kubernetes.reload.monitoring-secrets`      | `Boolean` | `false`                      | Allow monitoring changes in secrets
| `spring.cloud.kubernetes.reload.strategy `               | `Enum`    | `refresh`                    | The strategy to use when firing a reload (`refresh`, `restart_context`, or `shutdown`)
| `spring.cloud.kubernetes.reload.mode`                    | `Enum`    | `event`                      | Specifies how to listen for changes in property sources (`event` or `polling`)
| `spring.cloud.kubernetes.reload.period`                  | `Duration`| `15s`                        | The period for verifying changes when using the `polling` strategy
|===

Notes:
* You should not use properties under `spring.cloud.kubernetes.reload` in config maps or secrets. Changing such properties at runtime may lead to unexpected results.
* Deleting a property or the whole config map does not restore the original state of the beans when you use the `refresh` level.
